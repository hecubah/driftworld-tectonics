// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCirclePointsTexture

StructuredBuffer<float3> points;
int points_count;
float point_radius;

RWTexture2D<float4> Result;


float4 HSVtoRGB(float h, float s, float v)
{
    float c = v * s;
    float x = c * (float)(1 - (abs(((h / 60.0f) % 2) - 1)));
    float m = v - c;
    float ra, ga, ba;
    if (h < 60) {
        ra = c;
        ga = x;
        ba = 0;
    }
    else if (h < 120) {
        ra = x;
        ga = c;
        ba = 0;
    }
    else if (h < 180) {
        ra = 0;
        ga = c;
        ba = x;
    }
    else if (h < 240) {
        ra = 0;
        ga = x;
        ba = c;
    }
    else if (h < 300) {
        ra = x;
        ga = 0;
        ba = c;
    }
    else {
        ra = c;
        ga = 0;
        ba = x;
    }
    return float4(ra + m, ga + m, ba + m, 1);
}

[numthreads(4, 4, 4)]
void CSCirclePointsTexture (uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };
    int found_index = -1;

    float dot_product;
    for (int i = 0; i < points_count; i++) {
        dot_product = dot(w_pixelpoint, points[i]);
        if ((dot_product < 1 ? acos(dot_product) : 0) <= point_radius) {
            found_index = i;
        }
    }

    if (found_index == -1) {
        Result[pix_coords] = float4(0.2f, 0.2f, 0.2f, 1);
    }
    else {
        Result[pix_coords] = HSVtoRGB((float)found_index / (float)points_count * 360.0f, 1, 1);
    }

}

/*


void CSPlatesAreaTexture(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{

    for (int i = 0; i < n_plates; i++) {
        int help_index;
        if (found_plate == -1) {
            help_index = found_in_bv(0, offset, plate_transforms[i], w_pixelpoint);
            if (help_index != -1) {
                found_index = help_index;
                found_plate = i;
            }
        }
        else if (overlap_matrix[i * n_plates + found_plate] != -1)
        {
            help_index = found_in_bv(0, offset, plate_transforms[i], w_pixelpoint);
            if (help_index != -1) {
                found_index = help_index;
                found_plate = i;
            }
        }
        offset += BVH_array_sizes[i];
    }

    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
    else {
        Result[pix_coords] = HSVtoRGB((float)found_plate / (float)n_plates * 360.0f, 1, 1);
    }
}
*/