// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSTrianglePath

struct CSStructTriangle
{
    float3 A;
    float3 B;
    float3 C;
    uint neigh1;
    uint neigh2;
    uint neigh3;
    float a_val;
    float b_val;
    float c_val;
};

RWTexture2D<float4> Result;
StructuredBuffer<CSStructTriangle> triangles_input;
int triangleNumber;
float3 a;
float3 b;

bool isIn(float3 test_point, CSStructTriangle tri) {
    float3 abcross, bccross, cacross;
    float abplane_test, bcplane_test, caplane_test;
    abcross = cross(tri.A, tri.B);
    bccross = cross(tri.B, tri.C);
    cacross = cross(tri.C, tri.A);
    float3 triangle_barycenter = normalize(tri.A + tri.B + tri.C);
    abplane_test = dot(abcross, test_point);
    bcplane_test = dot(bccross, test_point);
    caplane_test = dot(cacross, test_point);
    if ((abplane_test * bcplane_test >= 0) && (bcplane_test * caplane_test >= 0) && (caplane_test * abplane_test >= 0) && (dot(triangle_barycenter, test_point) >= 0)) {
        return true;
    }
    else {
        return false;
    }



}

float dist(float3 a, float3 b) {
    return acos(dot(a, b));
}

[numthreads(4, 4, 4)]
void CSTrianglePath(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    uint2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float phi, theta;
    float PI = 3.141592653;
  
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    float4 col = float4(0,0,1,1);
    for (int i = 0; i < triangleNumber; i++) {
        if (isIn(w_pixelpoint, triangles_input[i])) {
            col = float4(0, 1, 0, 1);
        }
    }

    if (dist(w_pixelpoint, a) < 0.005)
        col = float4(0, 0, 0, 1);
    if (dist(w_pixelpoint, b) < 0.005)
        col = float4(0, 0, 0, 1);

    Result[pix_coords] = col;
}
