// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSTriangleCollisionTest

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

StructuredBuffer<float3> triangle_points;
StructuredBuffer<int> triangle_vertices;

bool is_in_tri(float3 searchedpoint, float3 a, float3 b, float3 c) {
    float3 abcross, bccross, cacross, triangle_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    abcross = cross(a, b);
    bccross = cross(b, c);
    cacross = cross(c, a);
    triangle_barycenter = normalize(a + b + c);
    abplane_test = dot(abcross, searchedpoint);
    bcplane_test = dot(bccross, searchedpoint);
    caplane_test = dot(cacross, searchedpoint);
    return ((abplane_test * bcplane_test >= 0) && (bcplane_test * caplane_test >= 0) && (caplane_test * abplane_test >= 0) && (dot(triangle_barycenter, searchedpoint) >= 0));
}


[numthreads(4,4,4)]
void CSTriangleCollisionTest(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;

    float phi, theta, aside, bside, cside;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int belonging_count = 0;

    if (is_in_tri(w_pixelpoint, triangle_points[triangle_vertices[0]], triangle_points[triangle_vertices[1]], triangle_points[triangle_vertices[2]])) {
        belonging_count++;
    }
    if (is_in_tri(w_pixelpoint, triangle_points[triangle_vertices[3]], triangle_points[triangle_vertices[4]], triangle_points[triangle_vertices[5]])) {
        belonging_count++;
    }

    float4 outCol;
    switch (belonging_count) {
    case 2:
        outCol = float4(1, 1, 1, 1);
        break;
    case 1:
        outCol = float4(0, 1, 0, 1);
        break;
    default:
        outCol = float4(0, 0, 1, 1);
        break;
    }
    
    Result[pix_coords] = outCol;


}
