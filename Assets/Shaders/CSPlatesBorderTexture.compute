// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSPlatesBorderTexture

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
StructuredBuffer<float3> triangle_points;
StructuredBuffer<int> point_values;
StructuredBuffer<int> triangle_neighbours;
int triangles_number;
int plates_number;

float dist(float3 a, float3 b) {
    return acos(dot(a, b));
}

float3 bcenter(float3 a, float3 b, float3 c) {
    return normalize(a + b + c);

}

bool is_in_tri(float3 searchedpoint, float3 a, float3 b, float3 c) {
    float3 abcross, bccross, cacross, triangle_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    abcross = cross(a, b);
    bccross = cross(b, c);
    cacross = cross(c, a);
    triangle_barycenter = normalize(a + b + c);
    abplane_test = dot(abcross, searchedpoint);
    bcplane_test = dot(bccross, searchedpoint);
    caplane_test = dot(cacross, searchedpoint);
    return ((abplane_test * bcplane_test >= 0) && (bcplane_test * caplane_test >= 0) && (caplane_test * abplane_test >= 0) && (dot(triangle_barycenter, searchedpoint) >= 0));
}

float barycentric_interpolation(float3 ipoint, float3 a, float a_val, float3 b, float b_val, float3 c, float c_val)
{
    float u, v, w;
    float3 v0 = b - a;
    float3 v1 = c - a;
    float3 v2 = ipoint - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    v = (d11 * d20 - d01 * d21) / denom;
    w = (d00 * d21 - d01 * d20) / denom;
    u = 1.0f - v - w;
    return (u * a_val + v * b_val + w * c_val);
}

float4 HSVtoRGB(float h, float s, float v)
{
    float c = v * s;
    float x = c * (float)(1 - (abs(((h / 60.0f) % 2) - 1)));
    float m = v - c;
    float ra, ga, ba;
    if (h < 60) {
        ra = c;
        ga = x;
        ba = 0;
    }
    else if (h < 120) {
        ra = x;
        ga = c;
        ba = 0;
    }
    else if (h < 180) {
        ra = 0;
        ga = c;
        ba = x;
    }
    else if (h < 240) {
        ra = 0;
        ga = x;
        ba = c;
    }
    else if (h < 300) {
        ra = x;
        ga = 0;
        ba = c;
    }
    else {
        ra = c;
        ga = 0;
        ba = x;
    }
    return float4(ra+m, ga+m, ba+m, 1);
}

[numthreads(4, 4, 4)]
void CSPlatesBorderTexture(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    int loop = 0;
    int MAX_LOOP = triangles_number;
    float phi, theta, aside, bside, cside;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };
    float3 abcross, bccross, cacross, triangle_barycenter, neigh1_barycenter, neigh2_barycenter, neigh3_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    int triangle_pointer = 0;
    triangle_barycenter = bcenter(triangle_points[0], triangle_points[1], triangle_points[2]);
    float triangle_pointer_dist = dist(triangle_barycenter, w_pixelpoint);
    bool closest_barycenter;
    int3 neighbours_indices;
    bool found = false;

    do {
        closest_barycenter = true;
        neighbours_indices.x = triangle_neighbours[3 * triangle_pointer];
        neighbours_indices.y = triangle_neighbours[3 * triangle_pointer + 1];
        neighbours_indices.z = triangle_neighbours[3 * triangle_pointer + 2];
        neigh1_barycenter = bcenter(triangle_points[3 * neighbours_indices.x], triangle_points[3 * neighbours_indices.x + 1], triangle_points[3 * neighbours_indices.x + 2]);
        neigh2_barycenter = bcenter(triangle_points[3 * neighbours_indices.y], triangle_points[3 * neighbours_indices.y + 1], triangle_points[3 * neighbours_indices.y + 2]);
        neigh3_barycenter = bcenter(triangle_points[3 * neighbours_indices.z], triangle_points[3 * neighbours_indices.z + 1], triangle_points[3 * neighbours_indices.z + 2]);

        if (dist(neigh1_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh1_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.x;
            closest_barycenter = false;
        }
        if (dist(neigh2_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh2_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.y;
            closest_barycenter = false;
        }
        if (dist(neigh3_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh3_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.z;
            closest_barycenter = false;
        }
        loop++;
    } while ((!closest_barycenter) && (loop < MAX_LOOP));

    neighbours_indices.x = triangle_neighbours[3 * triangle_pointer];
    neighbours_indices.y = triangle_neighbours[3 * triangle_pointer + 1];
    neighbours_indices.z = triangle_neighbours[3 * triangle_pointer + 2];

    if (is_in_tri(w_pixelpoint, triangle_points[3 * neighbours_indices.x], triangle_points[3 * neighbours_indices.x + 1], triangle_points[3 * neighbours_indices.x + 2])) {
        triangle_pointer = neighbours_indices.x;
    }

    if (is_in_tri(w_pixelpoint, triangle_points[3 * neighbours_indices.y], triangle_points[3 * neighbours_indices.y + 1], triangle_points[3 * neighbours_indices.y + 2])) {
        triangle_pointer = neighbours_indices.y;
    }

    if (is_in_tri(w_pixelpoint, triangle_points[3 * neighbours_indices.z], triangle_points[3 * neighbours_indices.z + 1], triangle_points[3 * neighbours_indices.z + 2])) {
        triangle_pointer = neighbours_indices.z;
    }

    int a_plate, b_plate, c_plate;
    a_plate = point_values[3 * triangle_pointer];
    b_plate = point_values[3 * triangle_pointer + 1];
    c_plate = point_values[3 * triangle_pointer + 2];
    
    float plate_hue;

    if ((a_plate == b_plate) && (b_plate == c_plate)) {
        
        Result[pix_coords] = HSVtoRGB((float)a_plate/(float)plates_number*360.0f, 1, 1);
    }
    else {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }

}

/*
[numthreads(4, 4, 4)]
void CSDefaultTerrainTexture(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    int loop = 0;
    int MAX_LOOP = trianglesNumber;
    float phi, theta, aside, bside, cside;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };
    float3 abcross, bccross, cacross, triangle_barycenter, neigh1_barycenter, neigh2_barycenter, neigh3_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    int triangle_pointer = 0;
    triangle_barycenter = bcenter(triangle_points[0], triangle_points[1], triangle_points[2]);
    float triangle_pointer_dist = dist(triangle_barycenter, w_pixelpoint);
    bool closest_barycenter;
    int3 neighbours_indices;
    bool found = false;

    do {
        closest_barycenter = true;
        neighbours_indices.x = triangle_neighbours[3 * triangle_pointer];
        neighbours_indices.y = triangle_neighbours[3 * triangle_pointer + 1];
        neighbours_indices.z = triangle_neighbours[3 * triangle_pointer + 2];
        neigh1_barycenter = bcenter(triangle_points[3 * neighbours_indices.x], triangle_points[3 * neighbours_indices.x + 1], triangle_points[3 * neighbours_indices.x + 2]);
        neigh2_barycenter = bcenter(triangle_points[3 * neighbours_indices.y], triangle_points[3 * neighbours_indices.y + 1], triangle_points[3 * neighbours_indices.y + 2]);
        neigh3_barycenter = bcenter(triangle_points[3 * neighbours_indices.z], triangle_points[3 * neighbours_indices.z + 1], triangle_points[3 * neighbours_indices.z + 2]);

        if (dist(neigh1_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh1_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.x;
            closest_barycenter = false;
        }
        if (dist(neigh2_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh2_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.y;
            closest_barycenter = false;
        }
        if (dist(neigh3_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh3_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.z;
            closest_barycenter = false;
        }
        loop++;
    } while ((!closest_barycenter) && (loop < MAX_LOOP));
    float grey_value = float(loop) / float(250);
    Result[pix_coords] = float4(grey_value, grey_value, grey_value, 1);
}
*/