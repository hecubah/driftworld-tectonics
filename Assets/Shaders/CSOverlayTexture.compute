#pragma kernel CSOverlayTextureBasicTerrain // green for continental, blue for ocean
#pragma kernel CSOverlayTextureDebugDataIndividualTriangles // data layer triangle areas
#pragma kernel CSOverlayTextureDebugDataTriangles // data layer triangle areas
#pragma kernel CSOverlayTextureDebugDataFailedTriangles // data layer triangle areas
#pragma kernel CSOverlayTextureCrustAge // crust age hue
#pragma kernel CSOverlayTextureOrogeny // texture orogeny hue
#pragma kernel CSOverlayTextureCrustPlates // crust plates areas, black borders
#pragma kernel CSOverlayTextureDebugCrustIndividualTriangles // crust triangle areas, black borders
#pragma kernel CSOverlayTextureDebugCrustTriangles // crust triangle areas, black borders
#pragma kernel CSOverlayTextureDebugCrustFailedTriangles // data layer triangle areas
#pragma kernel CSOverlayTextureElevationLaplacian // laplacian hue
#pragma kernel CSOverlayTextureDebugVectorNoise // direction and magnitude into hue and saturation

#include "Shared.compute"

RWTexture2D<float4> Result; // output texture for overlays




// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureBasicTerrain(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1) {
        Result[pix_coords] = float4(1, 0, 0, 1);
    }
    else {
        vertex_data data = data_barycentric_interpolation(w_pixelpoint, found_index);
        if (data.elevation >= 0) { // points below ocean level are blue, green otherwise
          Result[pix_coords] = float4(0, 1, 0, 1);
        } else {
          Result[pix_coords] = float4(0, 0, 1, 1);
        }
    }
}

// Overlay showing hued individual data triangles. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugDataIndividualTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float) pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float) pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1)
    {
        Result[pix_coords] = float4(0, 0, 0, 1); // if not found, point is black
    }
    else
    {
        Result[pix_coords] = HSVtoRGB((float) ((uint) found_index % 31) / 31.0f * 360.0f, 1, 1); // 31 hues of triangles, paint whole triangle in a single color
    }
}

// Overlay showing data triangles, hued and saturated by their coordinates (longitude hue, latitude saturation). Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugDataTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float) pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float) pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1)
    {
        Result[pix_coords] = float4(0, 0, 0, 1); // if not found, point is black
    }
    else
    {
        float3 coor_xyz = normalize(data_vertex_locations[data_triangles[found_index].a] + data_vertex_locations[data_triangles[found_index].b] + data_vertex_locations[data_triangles[found_index].c]);
        float longitude_deg = clamp((atan2(coor_xyz.x, coor_xyz.z) + PI) / PI * 180.0f, 0.0f, 360.0f);
        float latitude_norm = clamp(acos(abs(coor_xyz.y)) / PI * 2, 0.0, 1.0f);

        Result[pix_coords] = HSVtoRGB(longitude_deg, latitude_norm, 1); // 31 hues of triangles, paint whole triangle in a single color
    }
}

// Overlay showing contrast points where no data triangle has been found.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugDataFailedTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float) pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float) pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1)
    {
        Result[pix_coords] = float4(1, 1, 1, 1); // if not found, point is white
    }
    else
    {
        Result[pix_coords] = float4(0, 0, 0, 1); // if found, point is black
    }
}

// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
[numthreads(4, 4, 4)]
void CSOverlayTextureCrustAge(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    // x coordinate: gID.x sets 16 pixels rectangle offset to batch rectangle, gtID.z jumps by 4 pixels, gtID.x then sets final specific pixel x coordinate
    // y coordinate: gID.y sets 4 pixels rectangle offset to batch rectangle, gtID.y then sets final specific pixel y coordinate
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653; // some weird number :)
    float phi, theta; // spherical coordinates of pixels
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI; // phi is calculated as a quantization of [0, 2 * PI] interval
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI; // theta is calculated as a quantization of [0, PI] interval
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) }; // calculate cartesian coordinates (point on 3D sphere) for look-up

    int found_index = search_data_bvh_for_point(w_pixelpoint); // look for the point in the data bounding volume hiearchy

    if (found_index == -1) { // if not found, assign black
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
    else {
        vertex_data data = data_barycentric_interpolation(w_pixelpoint, found_index); // interpolate crust data
        Result[pix_coords] = HSVtoRGB((total_tectonic_steps_taken > 0 ? (1.0f - data.age / ((float)tectonic_iteration_step_time * (float)total_tectonic_steps_taken)) * 180.0f : 0.0f), 1, 1); // scale relative age to hue, green is newest, red oldest
    }
}

// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureOrogeny(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
    else {
        vertex_data data = data_barycentric_interpolation(w_pixelpoint, found_index);
        if (data.orogeny == 0) {
          Result[pix_coords] = float4(0.5f, 0.0f, 0.0f, 1.0f); // dark red for Unknown
          } else if (data.orogeny == 1) {
            Result[pix_coords] = float4(0.0f, 1.0f, 0.0f, 1.0f); // green for Andean
          } else if (data.orogeny == 2) {
            Result[pix_coords] = float4(0.0f, 0.0f, 1.0f, 1.0f); // blue for Himalayan
          } else {
            Result[pix_coords] = float4(0.0f, 0.0f, 0.0f, 1.0f); // blue for Error
          }
    }
}

// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureCrustPlates(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = -1; // plate look-up variables
    int found_plate = -1;

    for (int i = 0; i < n_plates; i++) { // only evaluate the top found triangles, check for overlaps in all plates
        int help_index;
        if ((found_plate == -1) || (overlap_matrix[i * n_plates + found_plate] != -1)) { // if plate not found yet or found in a plate triangle above, rewrite

            help_index = search_plate_bvh_for_point(w_pixelpoint, i);
            if (help_index != -1) {
                found_index = help_index;
                found_plate = i;
            }
        }
    }
    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1); // pixel not found in any plate are black

    }
    else {
      Result[pix_coords] = HSVtoRGB((float)found_plate / (float)n_plates * 360.0f, 1, 1); // different plates are scaled in hue, single color for the whole plate
    }
}

// Overlay showing hued individual triangles in crust plates. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge. Crust mechanism in CSOverlayTextureCrustPlates.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugCrustIndividualTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = -1;
    int found_plate = -1;

    for (int i = 0; i < n_plates; i++) {
        int help_index;
        if ((found_plate == -1) || (overlap_matrix[i * n_plates + found_plate] != -1)) {

            help_index = search_plate_bvh_for_point(w_pixelpoint, i);
            if (help_index != -1) {
                found_index = help_index;
                found_plate = i;
            }
        }
    }
    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1);

    }
    else {
      Result[pix_coords] = HSVtoRGB((float)((uint)found_index % 31)/31.0f * 360.0f, 1, 1); // Same as CSOverlayTextureDebugDataTriangles
    }
}

// Overlay showing triangles in crust plates, hued and saturated by their coordinates (longitude hue, latitude saturation). Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge. Crust mechanism in CSOverlayTextureCrustPlates.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugCrustTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float) pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float) pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = -1;
    int found_plate = -1;

    for (int i = 0; i < n_plates; i++)
    {
        int help_index;
        if ((found_plate == -1) || (overlap_matrix[i * n_plates + found_plate] != -1))
        {

            help_index = search_plate_bvh_for_point(w_pixelpoint, i);
            if (help_index != -1)
            {
                found_index = help_index;
                found_plate = i;
            }
        }
    }
    if (found_index == -1)
    {
        Result[pix_coords] = float4(0, 0, 0, 1);

    }
    else
    {
        float3 coor_xyz = quat_rot(normalize(crust_vertex_locations[crust_triangles[found_index].a] + crust_vertex_locations[crust_triangles[found_index].b] + crust_vertex_locations[crust_triangles[found_index].c]), plate_transforms[found_plate]);
        float longitude_deg = clamp((atan2(coor_xyz.x, coor_xyz.z) + PI) / PI * 180.0f, 0.0f, 360.0f);
        float latitude_norm = clamp(acos(abs(coor_xyz.y)) / PI * 2, 0.0, 1.0f);

        Result[pix_coords] = HSVtoRGB(longitude_deg, latitude_norm, 1); // 31 hues of triangles, paint whole triangle in a single color
    }
}

// Overlay showing contrast points where no crust triangle has been found.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge. Crust mechanism in CSOverlayTextureCrustPlates.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugCrustFailedTriangles(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float) pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float) pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = -1;
    int found_plate = -1;

    for (int i = 0; i < n_plates; i++)
    {
        int help_index;
        if ((found_plate == -1) || (overlap_matrix[i * n_plates + found_plate] != -1))
        {

            help_index = search_plate_bvh_for_point(w_pixelpoint, i);
            if (help_index != -1)
            {
                found_index = help_index;
                found_plate = i;
            }
        }
    }
    if (found_index == -1)
    {
        Result[pix_coords] = float4(1, 1, 1, 1);
    }
    else
    {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
}

// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureElevationLaplacian(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
    else {
      float lap_int = laplacian_interpolation(w_pixelpoint, found_index);
      Result[pix_coords] = HSVtoRGB((lap_int - el_min)/(el_max - el_min) * 180.0f, 1, 0.5f); // laplacian values are hue scaled from red to green, red are the largest values
    }
}

// Overlay showing crust age as hue. Calculates 4096x4096 texture.
// A dispatch has 256 x-size and 1024 y-size. One batch then corresponds to 16x4 pixels rectangle.
// Detailed comments in CSOverlayTextureCrustAge.
[numthreads(4, 4, 4)]
void CSOverlayTextureDebugVectorNoise(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    float phi, theta;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y+0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };

    int found_index = search_data_bvh_for_point(w_pixelpoint);

    if (found_index == -1) {
        Result[pix_coords] = float4(0, 0, 0, 1);
    }
    else {
      float3 bcenter = normalize(data_vertex_locations[data_triangles[found_index].a] + data_vertex_locations[data_triangles[found_index].b] + data_vertex_locations[data_triangles[found_index].c]);
      float3 longitude_direction = cross(bcenter, float3(0.0f, 1.0f, 0.0f)); // vector pointing along longitude
      longitude_direction = length(longitude_direction) > 0 ? normalize(longitude_direction) : longitude_direction;
      float noise_localx = length(vector_noise[found_index] - (dot(vector_noise[found_index], longitude_direction) * longitude_direction)); // decompose the noise vector along longitude
      float noise_localy = dot(vector_noise[found_index], longitude_direction);
      float noise_hue_angle = max(0, atan2(noise_localy, noise_localx) + 3.141592653f); // relative local angle is hue
      float intensity = length(vector_noise[found_index]); // magnitude is saturation
      Result[pix_coords] = HSVtoRGB(noise_hue_angle/3.141593653f*180, min(1, intensity), 1); // hue is scaled to 180
    }
}
