// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSDataToRender
#pragma warning( disable : 4714 ) // excess L1 cache registers
#define MAX_BVS_SEARCHED 256
#define EPSILON_TOLERANCE 0.00001f
#define DEBUG_MISSING_ELEVATION -0.5f

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
StructuredBuffer<float3> triangle_points;
StructuredBuffer<int> triangle_neighbours;
StructuredBuffer<float> point_values;

StructuredBuffer<int> overlap_matrix;
struct BV {
    int n_children;
    int left_child;
    int right_child;
    int triangle_index;
    float3 circumcenter;
    float circumradius;
};

StructuredBuffer<BV> BVH_array;
StructuredBuffer<float3> render_vertices;
int n_render_vertices;
RWStructuredBuffer<float> elevations_out;

float dist(float3 a, float3 b) {
    return acos(dot(a, b));
}

float3 bcenter(float3 a, float3 b, float3 c) {
    return normalize(a + b + c);

}

bool is_in_tri(float3 searchedpoint, float3 a, float3 b, float3 c) {
    float3 abcross, bccross, cacross, triangle_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    abcross = cross(a, b);
    bccross = cross(b, c);
    cacross = cross(c, a);
    triangle_barycenter = normalize(a + b + c);
    abplane_test = dot(abcross, searchedpoint);
    bcplane_test = dot(bccross, searchedpoint);
    caplane_test = dot(cacross, searchedpoint);
    return ((abplane_test + EPSILON_TOLERANCE >= 0) && (bcplane_test + EPSILON_TOLERANCE >= 0) && (caplane_test + EPSILON_TOLERANCE >= 0));
}

float barycentric_interpolation(float3 ipoint, float3 a, float a_val, float3 b, float b_val, float3 c, float c_val)
{
    float u, v, w;
    float3 v0 = b - a;
    float3 v1 = c - a;
    float3 v2 = ipoint - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    v = (d11 * d20 - d01 * d21) / denom;
    w = (d00 * d21 - d01 * d20) / denom;
    u = 1.0f - v - w;
    return (u * a_val + v * b_val + w * c_val);
}

int found_in_bv(int index, float3 needle) {
    int searched_indices_buffer[MAX_BVS_SEARCHED];
    int found_index = -1;

    int border_index = 0;
    int current_index = 0;

    searched_indices_buffer[border_index] = index;
    border_index++;

    while (current_index < min(border_index, MAX_BVS_SEARCHED)) {
        int candidate_index = searched_indices_buffer[current_index];
        BV candidate = BVH_array[candidate_index];
        float dot_prod = dot(needle, candidate.circumcenter);
        float multiplier = (candidate.circumradius < 0.005f ? 1.5f : 1.1f);

        float dist = (dot_prod < 1 ? acos(dot_prod) : 0.0f);
        if (dist <= candidate.circumradius * multiplier) {
            if (candidate.n_children == 2) {
                searched_indices_buffer[border_index] = candidate.left_child;
                border_index++;
                searched_indices_buffer[border_index] = candidate.right_child;
                border_index++;
            }
            else {
                int trindex = candidate.triangle_index;
                bool check = is_in_tri(needle, triangle_points[3 * trindex + 0], triangle_points[3 * trindex + 1], triangle_points[3 * trindex + 2]);
                if (check) {
                    return trindex;
                }
                else {
                    int tune_index = triangle_neighbours[3 * trindex + 0];
                    check = is_in_tri(needle, triangle_points[3 * tune_index + 0], triangle_points[3 * tune_index + 1], triangle_points[3 * tune_index + 2]);
                    if (check) {
                        return tune_index;
                    }
                    else {
                        tune_index = triangle_neighbours[3 * trindex + 1];
                        check = is_in_tri(needle, triangle_points[3 * tune_index + 0], triangle_points[3 * tune_index + 1], triangle_points[3 * tune_index + 2]);
                        if (check) {
                            return tune_index;
                        }
                        else {
                            tune_index = triangle_neighbours[3 * trindex + 2];
                            check = is_in_tri(needle, triangle_points[3 * tune_index + 0], triangle_points[3 * tune_index + 1], triangle_points[3 * tune_index + 2]);
                            if (check) {
                                return tune_index;
                            }
                        }

                    }
                }
            }
        }
        current_index++;
    }
    return found_index;
}

[numthreads(64, 1, 1)]
void CSDataToRender(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int ivi = gID.x * 64 + gtID.x; // interpolated vertex index
    if (ivi >= n_render_vertices) {
        return;
    }
    float3 iv = render_vertices[ivi];
    int found_index = -1;

    int help_index;
    help_index = found_in_bv(0, iv);
    if (help_index != -1) {
        found_index = help_index;
    }


    if (found_index == -1) {
        elevations_out[ivi] = DEBUG_MISSING_ELEVATION;
    }
    else {
        elevations_out[ivi] = barycentric_interpolation(iv, triangle_points[3 * found_index + 0], point_values[3 * found_index + 0], triangle_points[3 * found_index + 1], point_values[3 * found_index + 1], triangle_points[3 * found_index + 2], point_values[3 * found_index + 2]);
    }
}

/*
[numthreads(4, 4, 4)]
void CSDefaultTerrainTexture(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID)
{
    int2 pix_coords = { 16 * gID.x + 4 * gtID.z + gtID.x, 4 * gID.y + gtID.y };
    float PI = 3.141592653;
    int loop = 0;
    int MAX_LOOP = trianglesNumber;
    float phi, theta, aside, bside, cside;
    phi = ((float)pix_coords.x + 0.5f) / 4096.0f * 2 * PI;
    theta = (1.0f - ((float)pix_coords.y + 0.5f) / 4096.0f) * PI;
    float3 w_pixelpoint = { sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi) };
    float3 abcross, bccross, cacross, triangle_barycenter, neigh1_barycenter, neigh2_barycenter, neigh3_barycenter;
    float abplane_test, bcplane_test, caplane_test;
    int triangle_pointer = 0;
    triangle_barycenter = bcenter(triangle_points[0], triangle_points[1], triangle_points[2]);
    float triangle_pointer_dist = dist(triangle_barycenter, w_pixelpoint);
    bool closest_barycenter;
    int3 neighbours_indices;
    bool found = false;

    do {
        closest_barycenter = true;
        neighbours_indices.x = triangle_neighbours[3 * triangle_pointer];
        neighbours_indices.y = triangle_neighbours[3 * triangle_pointer + 1];
        neighbours_indices.z = triangle_neighbours[3 * triangle_pointer + 2];
        neigh1_barycenter = bcenter(triangle_points[3 * neighbours_indices.x], triangle_points[3 * neighbours_indices.x + 1], triangle_points[3 * neighbours_indices.x + 2]);
        neigh2_barycenter = bcenter(triangle_points[3 * neighbours_indices.y], triangle_points[3 * neighbours_indices.y + 1], triangle_points[3 * neighbours_indices.y + 2]);
        neigh3_barycenter = bcenter(triangle_points[3 * neighbours_indices.z], triangle_points[3 * neighbours_indices.z + 1], triangle_points[3 * neighbours_indices.z + 2]);

        if (dist(neigh1_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh1_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.x;
            closest_barycenter = false;
        }
        if (dist(neigh2_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh2_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.y;
            closest_barycenter = false;
        }
        if (dist(neigh3_barycenter, w_pixelpoint) < triangle_pointer_dist) {
            triangle_pointer_dist = dist(neigh3_barycenter, w_pixelpoint);
            triangle_pointer = neighbours_indices.z;
            closest_barycenter = false;
        }
        loop++;
    } while ((!closest_barycenter) && (loop < MAX_LOOP));
    float grey_value = float(loop) / float(250);
    Result[pix_coords] = float4(grey_value, grey_value, grey_value, 1);
}
*/